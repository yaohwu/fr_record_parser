# v1

## 数据描述

近800的用户，对于1300个模板在17年4月到11月，8个月内的预览记录。

## 时序分析预测和推荐

### 针对用户的历史记录，预测用户未来某个时间的预览

时序数据的预测

先简单一点，针对某一个用户：
单个用户的记录拿出来，以一天 24*60m 和预览模板为 x 轴和 y 轴，模板名称为系列作图。

应该找一些数据比较多的，我是直接随便找了，就 dirk 吧。

// todo

## 协同过滤预测和推荐

基于电影推荐的思路去做模板推荐

协同过滤电影推荐是这样的，每一个用户对电影都有一个评分，m 个用户对 n 个电影有 m*n 个评分，数据矩阵如下

| move/user | movie2 | movie3 | movie4 | ... | movieN |
| --------- | ------ | ------ | ------ | --- | ------ |
| __user1__ | 1      | 0      | 4      | ... | 3      |
| __user2__ | 2      | 3      | 0      | ... | 2      |
| __user3__ | 5      | 2      | 2      | ... | 4      |
| __...__   | ...    | ...    | ...    | ... | ...    |
| __userM__ | 5      | 2      | 2      | ... | 4      |

就有两种思路，基于用户的，或者说基于电影的。

### 基于用户的

就是依据用户对电影的评分，找到相似的用户（他们评分高的电影非常相同），那么对于用户 A 的推荐就是：找到 K 个和用户 A 非常相同的用户，将这些用户最喜欢的电影中去除掉 A 已经喜欢的，然后推荐给 A。

### 基于项目的

在电影中就是基于电影的，在我们的模板推荐里面就是基于模板的。

也是依据用户对电影的评分，找到相似的电影（喜欢他们的人群非常相同），那么对于用户 A 的推荐就是：找到 K 个用户 A 非常喜欢的电影，然后找出 和 K 个电影 最相似的 K 个电影。

基于用户的协同过滤推荐和基于项目的协同过滤推荐都是基于物品相似度的预测推荐，只是相似度度量的维度不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息。

如果是基于协同过滤去做，那么我们需要一个用户对于模板的评分计算机制，因为我们是没有评分的，所以引入一个评分逻辑去计算一下评分。

接下来就是全部属于“臆测”了。

粗劣的评分逻辑：不管预览的次数，直接预览过就算加分。根据过十天的预览记录进行加分，满分十分。

有一个处理**遗忘因子**的模型 [wiki 地址](https://en.wikipedia.org/wiki/Recursive_least_squares_filter)

我们先订一个简单的规则来处理这个遗忘的因素
| over 10 | 10  | 8   | 6   | 4   | 2   | now  |
| ------- | --- | --- | --- | --- | --- | ---- |
| 0分     | 1分 | 2分 | 3分 | 4分 | 5分 | 分数 |

那么去计算分数吧。

先取一天作为now，比如，5月18号

通过*data_cf.py*中的方法，我们处理得到一个 793（用户）*1262（模板）的矩阵结果。
结果保存在result.csv文件

基于用户做协同过滤

* 先找出K个和待预测用户 A 相似的用户。

借助[皮尔逊相关系数](https://zh.wikipedia.org/wiki/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%A7%AF%E7%9F%A9%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0)描述用户间的相似程度。

计算相关系数的时候出现了点问题：
由于我们使用的用户属性维度很大，我们是使用用户对于1300个模板的评分去计算维度的，在指定的评分规则下，有些用户可能一个分数也没有；延缓策略为只对评过分的进行处理。

* 找到这 K 个用户 兴趣程度比较高的模板，进行一定的加权计算兴趣程度，然后排序推荐前 M 个模板给用户 A。

寻找的完全不相关，设置的时间区间太小了，*10 放大一下。

k=10

```shell
# 相关度比较高的用户
[(77, 1.0), (445, 0.6953703509061951), (232, 0.656756096515176), (57, 0.6488800338383531), (18, 0.6420183805680368), (295, 0.6363226366384254), (476, 0.6292870835965547), (146, 0.6275607983819458), (389, 0.6220976476415238), (671, 0.6172197558338962), (616, 0.6155433815308516)]
```

去除用户 A 77 本身。

```shell
# user_id,P
[(445, 0.6953703509061951), (232, 0.656756096515176), (57, 0.6488800338383531), (18, 0.6420183805680368), (295, 0.6363226366384254), (476, 0.6292870835965547), (146, 0.6275607983819458), (389, 0.6220976476415238), (671, 0.6172197558338962), (616, 0.6155433815308516)]
```

寻找 这些相关程度高的用户最感兴趣的模板，进行加权计算后排序。
M=10

```shell
# tpl_id,score
[(13, 32.9419129666841), (18, 32.9419129666841), (95, 29.721483397607773), (57, 29.721477967995376), (232, 26.29687007476028), (146, 23.092770910019755), (63, 16.452553199424298), (73, 13.174114609639037), (155, 10.063774726374675), (273, 10.034760413985548)]
```

[命中率、召回率和 F 值](http://bookshadow.com/weblog/2014/06/10/precision-recall-f-measure/)

```python3
    # 准确率 = 提取出的正确信息条数 /  提取出的信息条数
    p = num_precision_tpl / num_predict_tpl
    # 召回率 = 提取出的正确信息条数 /  样本中的信息条数
    r = num_precision_tpl / num_real_preview
    # f1 F值  = 正确率 * 召回率 * 2 / (正确率 + 召回率) （F 值即为正确率和召回率的调和平均值）
```

```shell
    p: 0.6  r: 0.15789473684210525 f1: 0.25
```

## todo

1. 加入时间的概念，将用户的评分处理成时序的数据
2. 基于模型的协同过滤。基于用户或者基于项目都是基于记忆或者成为内容的协同过滤，它存在一些问题：诸如数据稀疏，计算量大（基于用户的 只是进行评分都要要跑15m）。引入基于模型的协同过滤